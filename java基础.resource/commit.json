{"compress":true,"commitItems":[["bdcf1c4a-5b41-4458-ba9b-9ae464568dc9",1546486451356,"---\nenable html: true\n---\n# Lorem ipsum\n\nLorem ipsum dolor sit amet, dictas cetero eam in, falli feugait ne duo. Agam causae dolorem ea sed. Eam mollis maiorum assueverit eu <span style=\"color: red;\">per stet quidam molestiae eu</span>. Omnesque inimicus accusamus id quo.\n\nTamquam facilisi ea eum, reque saepe interpretaris ex usu, nibh explicari ei qui.\n\n```javascript\nconsole.log(Array.from('foo'));\n// expected output: Array [\"f\", \"o\", \"o\"]\n\nconsole.log(Array.from([1, 2, 3], x => x + x));\n// expected output: Array [2, 4, 6]\n```\n\n## Syntax\n\n    Lorem.ipsum(epicurei[, saepe[, explicari]])\n\n**Parameters**\n\n| Senserit  | Repudiandae                         | Vis |\n| --------- | ----------------------------------- | --- |\n| epicurei  | Usu no tale prima, vis fugit  id.   | Cu  |\n| saepe     | Ea vis graecis concludaturque.      | Cum |\n| explicari | Clita quando `this` in mea `saepe`. | Cum |\n\n**Return value**\n\nEa alii putent integre sed.\n",[[1546486407399,["xiebo@LAPTOP-R498IA2V",[[-1,28,"Lorem ipsum"],[1,39,"java基础"]],[28,39],[34,34]]],[1546486423033,["xiebo@LAPTOP-R498IA2V",[[-1,36,"Lorem ipsum dolor sit amet, dictas cetero eam in, falli feugait ne duo. Agam causae dolorem ea sed. Eam mollis maiorum assueverit eu <span style=\"color: red;\">per stet quidam molestiae eu</span>. Omnesque inimicus accusamus id quo.\n\nTamquam facilisi ea eum, reque saepe interpretaris ex usu, nibh explicari ei qui.\n\n```javascript\nconsole.log(Array.from('foo'));\n// expected output: Array [\"f\", \"o\", \"o\"]\n\nconsole.log(Array.from([1, 2, 3], x => x + x));\n// expected output: Array [2, 4, 6]\n```\n\n## Syntax\n\n    Lorem.ipsum(epicurei[, saepe[, explicari]])\n\n**Parameters**\n\n| Senserit  | Repudiandae                         | Vis |\n| --------- | ----------------------------------- | --- |\n| epicurei  | Usu no tale prima, vis fugit  id.   | Cu  |\n| saepe     | Ea vis graecis concludaturque.      | Cum |\n| explicari | Clita quando `this` in mea `saepe`. | Cum |\n\n**Return value**\n\nEa alii putent integre sed."]],[36,942],[36,36]]],[1546486423302,["xiebo@LAPTOP-R498IA2V",[[1,36,"**t****his关键字：**\n　　this代表当前对象，它有以下几种用途：\n　　1、本类中在非静态方法中条用非静态变量和方法，就可以使用【this.变量名】和【this.方法名(参数列表)】的方式调用，实际情况是,this关键字通常会被省略。\n　　2、就在上面这种情况下，有一个特殊情况，那就是在方法中定义了一个与类成员变量同名的局部变量，这是在方法内部调用类的成员变量就必须使用this关键字来点用。\n　　3、在构造方法中使用：在存在构造方法重构（overlode）的类中，使用【this(参数列表)】的方式调用本类中的其他构造方法，且必须放置于构造方法的第一句。\n\n**　　super关键字：**\n　　super代表父类对象，它与this不同，用途如下：\n　　1、子类重写父类方法之后，再次调用父类的该方法，必须使用【super.方法名(参数列表)】调用。\n　　2、子类的构造方法中默认存在父类的无参构造方法，也可以显式声明其他的构造方法，声明必须使用【super(列表参数)】。\n　　3、在构造方法中，super与this关键字不能同时出现，且均位于构造方法首行。\n\n**　　类的封装：**\n　　为了保护类内部内容的安全，不被客户程序任意调用，将这些内容修饰为private，这些内容将只会对本类可见，包括子类在内的任何异类均无访问权限，为了实现对这些数据的访问修改，添加了setName(参数列表)和getName()公共方法来被外部类调用。这样避免了数据的无端访问，保护了数据的安全，即封装。\n\n**　　类的继承：**\n　　1、一个类可以继承另一个类，这样前者就拥有后者内部的所有内容，但是父类中的被private修饰的内容子类是无法访问的，这时在子类中使用父类中的内容相当于使用本类中的内容。\n　　2、被final修饰的类无法被继承。\n　　3、一个类只能继承一个类，即单继承，继承使用extends关键字。\n　　4、构造方法不能被继承\n　　5、父类中的静态变量在子类中访问时，可以you父类点用，子类点用，直接使用三种方式，他们的作用一样。\n　　6、子类的构造方法必须包含父类的构造方法，即在创建子类的对象实例时，会优先调用父类的构造方法来创建父类的实例对象，再调用子类的构造方法创建子类的实例对象。\n　　7、子类汇总的构造方法默认调用父类的无参构造方法（隐式调用），亦可人为显式指定某个父类构造方法：使用【super(参数列表)】调用\n　　8、类的继承通常会使用到重写操作（override），在保证父类某个方法的返回值、名称、参数列表不变的情况下优化更改方法体，重写后的方法不能使用比父类中被重写方法的更严格的权限修饰。\n　　9、父类中的某个方法被子类重写之后，想要调用父类中的原方法，需要借助【super.方法名(参数列表)】调用。\n　　10、在子类创建对象时，会在内存中加载子类字节码文件，加载时发现其继承自父类，那么会转向加载父类的字节码文件，在父类的字节码文件加载完成后，再返回来继续加载子类的字节码文件，加载完成后才会开始执行创建对象操作，创建子类对象时，调用子类构造方法必然会先调用父类的构造方法创建父类的对象，之后才会创建子类对象。\n\n　　下面是实验代码：自行查看"]],[36,36],[1385,1385]]],[1546486427922,["xiebo@LAPTOP-R498IA2V",[[-1,1371,"　　下面是实验代码：自行查看"]],[1373,1385],[1371,1371]]],[1546486428139,["xiebo@LAPTOP-R498IA2V",[[-1,1371,"\n"]],[1371,1371],[1370,1370]]],[1546486428327,["xiebo@LAPTOP-R498IA2V",[[-1,1370,"\n"]],[1370,1370],[1369,1369]]],[1546486436669,["xiebo@LAPTOP-R498IA2V",[[1,27,"**"],[1,34,"**"]],[27,34],[27,38]]],[1546486443834,["xiebo@LAPTOP-R498IA2V",[[1,27," "]],[27,27],[28,28]]],[1546486446407,["xiebo@LAPTOP-R498IA2V",[[1,31," "]],[30,30],[31,31]]],[1546486449032,["xiebo@LAPTOP-R498IA2V",[[-1,28,"** "]],[31,31],[28,28]]],[1546486451100,["xiebo@LAPTOP-R498IA2V",[[-1,35,"**"]],[37,37],[35,35]]],[1546486463172,["xiebo@LAPTOP-R498IA2V",[[-1,37,"**t****"]],[44,44],[37,37]]],[1546486470648,["xiebo@LAPTOP-R498IA2V",[[1,37,"**t"]],[37,37],[40,40]]],[1546486476188,["xiebo@LAPTOP-R498IA2V",[[-1,322,"　　"]],[322,324],[322,322]]],[1546486481816,["xiebo@LAPTOP-R498IA2V",[[-1,688,"　　"]],[688,690],[688,688]]],[1546486495595,["xiebo@LAPTOP-R498IA2V",[[-1,522,"　　"]],[522,524],[522,522]]]],null,"xiebo@LAPTOP-R498IA2V"],["e0578c19-2964-4975-b0d4-413ce58cd61a",1551099200280,"---\nenable html: true\n---\n#  java基础\n\n**this关键字：**\n　　this代表当前对象，它有以下几种用途：\n　　1、本类中在非静态方法中条用非静态变量和方法，就可以使用【this.变量名】和【this.方法名(参数列表)】的方式调用，实际情况是,this关键字通常会被省略。\n　　2、就在上面这种情况下，有一个特殊情况，那就是在方法中定义了一个与类成员变量同名的局部变量，这是在方法内部调用类的成员变量就必须使用this关键字来点用。\n　　3、在构造方法中使用：在存在构造方法重构（overlode）的类中，使用【this(参数列表)】的方式调用本类中的其他构造方法，且必须放置于构造方法的第一句。\n\n**super关键字：**\n　　super代表父类对象，它与this不同，用途如下：\n　　1、子类重写父类方法之后，再次调用父类的该方法，必须使用【super.方法名(参数列表)】调用。\n　　2、子类的构造方法中默认存在父类的无参构造方法，也可以显式声明其他的构造方法，声明必须使用【super(列表参数)】。\n　　3、在构造方法中，super与this关键字不能同时出现，且均位于构造方法首行。\n\n**类的封装：**\n　　为了保护类内部内容的安全，不被客户程序任意调用，将这些内容修饰为private，这些内容将只会对本类可见，包括子类在内的任何异类均无访问权限，为了实现对这些数据的访问修改，添加了setName(参数列表)和getName()公共方法来被外部类调用。这样避免了数据的无端访问，保护了数据的安全，即封装。\n\n**类的继承：**\n　　1、一个类可以继承另一个类，这样前者就拥有后者内部的所有内容，但是父类中的被private修饰的内容子类是无法访问的，这时在子类中使用父类中的内容相当于使用本类中的内容。\n　　2、被final修饰的类无法被继承。\n　　3、一个类只能继承一个类，即单继承，继承使用extends关键字。\n　　4、构造方法不能被继承\n　　5、父类中的静态变量在子类中访问时，可以you父类点用，子类点用，直接使用三种方式，他们的作用一样。\n　　6、子类的构造方法必须包含父类的构造方法，即在创建子类的对象实例时，会优先调用父类的构造方法来创建父类的实例对象，再调用子类的构造方法创建子类的实例对象。\n　　7、子类汇总的构造方法默认调用父类的无参构造方法（隐式调用），亦可人为显式指定某个父类构造方法：使用【super(参数列表)】调用\n　　8、类的继承通常会使用到重写操作（override），在保证父类某个方法的返回值、名称、参数列表不变的情况下优化更改方法体，重写后的方法不能使用比父类中被重写方法的更严格的权限修饰。\n　　9、父类中的某个方法被子类重写之后，想要调用父类中的原方法，需要借助【super.方法名(参数列表)】调用。\n　　10、在子类创建对象时，会在内存中加载子类字节码文件，加载时发现其继承自父类，那么会转向加载父类的字节码文件，在父类的字节码文件加载完成后，再返回来继续加载子类的字节码文件，加载完成后才会开始执行创建对象操作，创建子类对象时，调用子类构造方法必然会先调用父类的构造方法创建父类的对象，之后才会创建子类对象。\n",[[1551099179334,["xiebo@LAPTOP-R498IA2V",[[1,1361,"　　\n"]],[1360,1360],[1363,1363]]],[1551099180582,["xiebo@LAPTOP-R498IA2V",[[-1,1361,"　　"],[1,1363,"\n"]],[1363,1363],[1362,1362]]],[1551099180851,["xiebo@LAPTOP-R498IA2V",[[1,1362,"-static"]],[1362,1362],[1369,1369]]],[1551099202184,["xiebo@LAPTOP-R498IA2V",[[1,1370,"\n"]],[1369,1369],[1370,1370]]],[1551099202389,["xiebo@LAPTOP-R498IA2V",[[1,1370,"-初始化顺序             \n\n-静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。             -存在继承的情况下，初始化顺序为：                 \n\n父类（静态变量、静态语句块）                \n\n子类（静态变量、静态语句块）\n\n父类（实例变量、普通语句块）                 \n\n父类（构造函数）                 \n\n子类（实例变量、普通语句块）                 \n\n子类（构造函数）        \n\n-静态变量    private static int y;             \n\n-又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访它；静态变量在内存中\n\n只存在一份。"]],[1370,1370],[1761,1761]]],[1551099210959,["xiebo@LAPTOP-R498IA2V",[[1,1762,"\n"]],[1761,1761],[1762,1762]]],[1551099211192,["xiebo@LAPTOP-R498IA2V",[[1,1762,"静态方法\n\npublic static void func1(){}             \n\n-静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法             \n\n-只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。         \n\n-静态语句块    static {System.out.println(''123'');}            \n\n-静态语句块在类初始化时运行一次。\n\n-静态内部类    static class StaticInnerClass {}            \n\n-非静态内部类依赖于外部类的实例，而静态内部类不需要。\n\n-静态内部类不能访问外部类的非静态的变量和方法。\n\n-静态导包    import static com.xxx.ClassName.*\n\n-在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低"]],[1762,1762],[2209,2209]]],[1551099220158,["xiebo@LAPTOP-R498IA2V",[[1,2210,"\n"]],[2209,2209],[2210,2210]]],[1551099220484,["xiebo@LAPTOP-R498IA2V",[[1,2210,"-final            \n\n-声明字段\n\n-对于基本类型，final 使数值不变\n\nfinal int x = 1;                \n\n//x=0; 这里会报错：cannot assign value to final variable 'x'\n\n-对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。                \n\nfinal A y = new A();\n\ny.a = 1;        \n\n-声明方法\n\n-声明方法不能被子类重写。\n\n-private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的\n\n方法不是重写基类方法，而是在子类中定义了一个新的方法。        \n\n-声明类\n\n-声明类不允许被继承。\n\nObject 常见的方法"]],[2210,2210],[2610,2610]]],[1551099231640,["xiebo@LAPTOP-R498IA2V",[[1,2611,"\n"]],[2610,2610],[2611,2611]]],[1551099259982,["xiebo@LAPTOP-R498IA2V",[[1,2611,"![微信图片_20190225205344]($resource/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190225205344.gif)\n-主要方法\n\n-public boolean equals(Object obj)\n\n-public native int hashCode()         \n\n-public String toString()         \n\n-protected native Object clone() throws CloneNotSupportedException         \n\n-native关键字：            \n\n-一个native方法就是一个Java调用非Java代码的接口。一个native方法是指该方法的实现由非Java语言实现，比如用\n\nC或C++实现。"]],[2611,2611],[2996,2996]]],[1551099269690,["xiebo@LAPTOP-R498IA2V",[[1,2997,"\n"]],[2996,2996],[2997,2997]]],[1551099269904,["xiebo@LAPTOP-R498IA2V",[[1,2997,"-在定义一个native方法时，并不提供实现体（比较像定义一个Java Interface），因为其实现体是由非Java语言在外\n\n面实现的。\n\n-equals()\n\n-与null的比较\n\n-对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false\n\nx.equals(null); // false;\n\n-equals()和null区分            \n\n-对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。             -\n\n对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价     \n\n-hashCode()"]],[2997,2997],[3319,3319]]],[1551099277784,["xiebo@LAPTOP-R498IA2V",[[1,3320,"\n"]],[3319,3319],[3320,3320]]],[1551099277938,["xiebo@LAPTOP-R498IA2V",[[1,3321,"\n"]],[3320,3320],[3321,3321]]],[1551099278138,["xiebo@LAPTOP-R498IA2V",[[1,3321,"-主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable        \n\n-在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。\n\n-hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同\n\n的两个对象不一定等价。\n\n-toString()\n\n-将当前变量的数据类型转换为String类型,同时也方便打印输出\n\n-clone()"]],[3321,3321],[3581,3581]]],[1551099285640,["xiebo@LAPTOP-R498IA2V",[[1,3582,"\n"]],[3581,3581],[3582,3582]]],[1551099285980,["xiebo@LAPTOP-R498IA2V",[[1,3582,"-官方解释             \n\n-返回一个要克隆对象的副本，克隆的类型依赖被克隆对象         \n\n-误区             \n\n-clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定了这个方法。         \n\n-在使用clone()时需注意，需要抛出异常，和强制类型转换        \n\n-cloneable()\n\n-在需要clone的对象上实现（implements）Cloneable接口，然后再在类中加上clone方法，在方法中只需要调用\n\nsuper.clone()，即可根据自己的需要实现\n\n-浅拷贝                 \n\n-拷贝对象和原始对象的引用类型引用同一个对象        \n\n-深拷贝\n\n-拷贝对象和原始对象的引用类型引用不同对象。"]],[3582,3582],[3978,3978]]],[1551099295079,["xiebo@LAPTOP-R498IA2V",[[1,3979,"\n"]],[3978,3978],[3979,3979]]],[1551099295594,["xiebo@LAPTOP-R498IA2V",[[1,3980,"\n"]],[3979,3979],[3980,3980]]],[1551099295763,["xiebo@LAPTOP-R498IA2V",[[1,3980,"异常\n\n-检查性异常: 不处理编译不能通过\n\n非检查性异常:不处理编译可以通过，如果有抛出直接抛到控制台       \n\n运行时异常: 就是非检查性异常       \n\n非运行时异常: 就是检查性异常    \n\n-Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。\n\n-Error         -是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及"]],[3980,3980],[4216,4216]]],[1551099302088,["xiebo@LAPTOP-R498IA2V",[[1,4217,"\n"]],[4216,4216],[4217,4217]]],[1551099302643,["xiebo@LAPTOP-R498IA2V",[[1,4218,"\n"]],[4217,4217],[4218,4218]]],[1551099302850,["xiebo@LAPTOP-R498IA2V",[[1,4218,"Socket编程时出现的端口占用等程序无法处理的错误。\n\n-Exception         -分为运行时异常跟编译异常         \n\n-运行时异常             \n\n-即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获\n\n，但是程序员也可以根据需要进行捕获抛出。\n\n常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），\n\nIndexOutOfBoundsException（数组越界异常）等。\n\n-编译异常             \n\n-RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译\n\n异常有：IOException（流传输异常），   SQLException（数据库操作异常）等。"]],[4218,4218],[4637,4637]]],[1551099313197,["xiebo@LAPTOP-R498IA2V",[[1,4638,"\n"]],[4637,4637],[4638,4638]]],[1551099335307,["xiebo@LAPTOP-R498IA2V",[[1,4638,"![1]($resource/1.jpg)\n-java处理异常的机制：\n\n-抛出异常以及捕获异常（try---catch或try --- catch --- finally 代码块），一个方法所能捕捉的异常，一定是Java代码\n\n在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。\n\n-throw跟throws的区别:\n\n-throws是方法可能抛出异常的声明，throw是语句抛出一个异常（可以是自定义需继承Exception，也可以是java自己给\n\n出的异常类）\n\n-throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。\n\n八、java各版本特性\n\n-java5\n\n-很重要的一个版本，有泛型、枚举、自动装箱/拆箱、可变参数、注解、foreach循环、静态导入、新的线程模型等等更新。\n\n-java6\n\n-鸡肋的版本，有JDBC4.0更新、Complier API、WebSevice支持的加强等更新。\n\n-java7"]],[4638,4638],[5091,5091]]],[1551099343943,["xiebo@LAPTOP-R498IA2V",[[1,5092,"\n"]],[5091,5091],[5092,5092]]],[1551099344144,["xiebo@LAPTOP-R498IA2V",[[1,5092,"-有一些比较重要的更新，如异常处理增加了被抑制的异常、捕获多异常、try-with-resource自动释放资源等，还有应用了\n\nG1垃圾回收器、switch可以使用String类型、泛型自动判断类型、fork/join框架把任务细分并使用多处理器处理、支持二\n\n进制字面量等\n\n-java8         \n\n-很多的新特性，比如编译器、类库、开发工具和JVM（Java虚拟机）。         \n\n-最重要的一点，Java8开始支持了Lambda表达式    \n\n-java9\n\n-Java 平台级模块系统、Linking、Shell : 交互式 Java REPL、改进的 Javadoc等"]],[5092,5092],[5392,5392]]],[1551099346669,["xiebo@LAPTOP-R498IA2V",[[-1,5033,"\n"]],[5033,5033],[5032,5032]]],[1551099347761,["xiebo@LAPTOP-R498IA2V",[[-1,4964,"\n"]],[4964,4964],[4963,4963]]],[1551099353699,["xiebo@LAPTOP-R498IA2V",[[-1,5246,"\n"]],[5246,5246],[5245,5245]]],[1551099363163,["xiebo@LAPTOP-R498IA2V",[[-1,5332,"\n"]],[5332,5332],[5331,5331]]]],null,"xiebo@LAPTOP-R498IA2V"]]}