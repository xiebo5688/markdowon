---
enable html: true
---
#  java基础

**this关键字：**
　　this代表当前对象，它有以下几种用途：
　　1、本类中在非静态方法中条用非静态变量和方法，就可以使用【this.变量名】和【this.方法名(参数列表)】的方式调用，实际情况是,this关键字通常会被省略。
　　2、就在上面这种情况下，有一个特殊情况，那就是在方法中定义了一个与类成员变量同名的局部变量，这是在方法内部调用类的成员变量就必须使用this关键字来点用。
　　3、在构造方法中使用：在存在构造方法重构（overlode）的类中，使用【this(参数列表)】的方式调用本类中的其他构造方法，且必须放置于构造方法的第一句。

**super关键字：**
　　super代表父类对象，它与this不同，用途如下：
　　1、子类重写父类方法之后，再次调用父类的该方法，必须使用【super.方法名(参数列表)】调用。
　　2、子类的构造方法中默认存在父类的无参构造方法，也可以显式声明其他的构造方法，声明必须使用【super(列表参数)】。
　　3、在构造方法中，super与this关键字不能同时出现，且均位于构造方法首行。

**类的封装：**
　　为了保护类内部内容的安全，不被客户程序任意调用，将这些内容修饰为private，这些内容将只会对本类可见，包括子类在内的任何异类均无访问权限，为了实现对这些数据的访问修改，添加了setName(参数列表)和getName()公共方法来被外部类调用。这样避免了数据的无端访问，保护了数据的安全，即封装。

**类的继承：**
　　1、一个类可以继承另一个类，这样前者就拥有后者内部的所有内容，但是父类中的被private修饰的内容子类是无法访问的，这时在子类中使用父类中的内容相当于使用本类中的内容。
　　2、被final修饰的类无法被继承。
　　3、一个类只能继承一个类，即单继承，继承使用extends关键字。
　　4、构造方法不能被继承
　　5、父类中的静态变量在子类中访问时，可以you父类点用，子类点用，直接使用三种方式，他们的作用一样。
　　6、子类的构造方法必须包含父类的构造方法，即在创建子类的对象实例时，会优先调用父类的构造方法来创建父类的实例对象，再调用子类的构造方法创建子类的实例对象。
　　7、子类汇总的构造方法默认调用父类的无参构造方法（隐式调用），亦可人为显式指定某个父类构造方法：使用【super(参数列表)】调用
　　8、类的继承通常会使用到重写操作（override），在保证父类某个方法的返回值、名称、参数列表不变的情况下优化更改方法体，重写后的方法不能使用比父类中被重写方法的更严格的权限修饰。
　　9、父类中的某个方法被子类重写之后，想要调用父类中的原方法，需要借助【super.方法名(参数列表)】调用。
　　10、在子类创建对象时，会在内存中加载子类字节码文件，加载时发现其继承自父类，那么会转向加载父类的字节码文件，在父类的字节码文件加载完成后，再返回来继续加载子类的字节码文件，加载完成后才会开始执行创建对象操作，创建子类对象时，调用子类构造方法必然会先调用父类的构造方法创建父类的对象，之后才会创建子类对象。

-static
-初始化顺序             

-静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。             -存在继承的情况下，初始化顺序为：                 

父类（静态变量、静态语句块）                

子类（静态变量、静态语句块）

父类（实例变量、普通语句块）                 

父类（构造函数）                 

子类（实例变量、普通语句块）                 

子类（构造函数）        

-静态变量    private static int y;             

-又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访它；静态变量在内存中

只存在一份。
静态方法

public static void func1(){}             

-静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法             

-只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。         

-静态语句块    static {System.out.println(''123'');}            

-静态语句块在类初始化时运行一次。

-静态内部类    static class StaticInnerClass {}            

-非静态内部类依赖于外部类的实例，而静态内部类不需要。

-静态内部类不能访问外部类的非静态的变量和方法。

-静态导包    import static com.xxx.ClassName.*

-在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低
-final            

-声明字段

-对于基本类型，final 使数值不变

final int x = 1;                

//x=0; 这里会报错：cannot assign value to final variable 'x'

-对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。                

final A y = new A();

y.a = 1;        

-声明方法

-声明方法不能被子类重写。

-private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的

方法不是重写基类方法，而是在子类中定义了一个新的方法。        

-声明类

-声明类不允许被继承。

Object 常见的方法
![微信图片_20190225205344]($resource/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190225205344.gif)
-主要方法

-public boolean equals(Object obj)

-public native int hashCode()         

-public String toString()         

-protected native Object clone() throws CloneNotSupportedException         

-native关键字：            

-一个native方法就是一个Java调用非Java代码的接口。一个native方法是指该方法的实现由非Java语言实现，比如用

C或C++实现。
-在定义一个native方法时，并不提供实现体（比较像定义一个Java Interface），因为其实现体是由非Java语言在外

面实现的。

-equals()

-与null的比较

-对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false

x.equals(null); // false;

-equals()和null区分            

-对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。             -

对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价     

-hashCode()

-主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable        

-在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。

-hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同

的两个对象不一定等价。

-toString()

-将当前变量的数据类型转换为String类型,同时也方便打印输出

-clone()
-官方解释             

-返回一个要克隆对象的副本，克隆的类型依赖被克隆对象         

-误区             

-clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定了这个方法。         

-在使用clone()时需注意，需要抛出异常，和强制类型转换        

-cloneable()

-在需要clone的对象上实现（implements）Cloneable接口，然后再在类中加上clone方法，在方法中只需要调用

super.clone()，即可根据自己的需要实现

-浅拷贝                 

-拷贝对象和原始对象的引用类型引用同一个对象        

-深拷贝

-拷贝对象和原始对象的引用类型引用不同对象。

异常

-检查性异常: 不处理编译不能通过

非检查性异常:不处理编译可以通过，如果有抛出直接抛到控制台       

运行时异常: 就是非检查性异常       

非运行时异常: 就是检查性异常    

-Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。

-Error         -是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及

Socket编程时出现的端口占用等程序无法处理的错误。

-Exception         -分为运行时异常跟编译异常         

-运行时异常             

-即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获

，但是程序员也可以根据需要进行捕获抛出。

常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），

IndexOutOfBoundsException（数组越界异常）等。

-编译异常             

-RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译

异常有：IOException（流传输异常），   SQLException（数据库操作异常）等。
![1]($resource/1.jpg)
-java处理异常的机制：

-抛出异常以及捕获异常（try---catch或try --- catch --- finally 代码块），一个方法所能捕捉的异常，一定是Java代码

在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。

-throw跟throws的区别:

-throws是方法可能抛出异常的声明，throw是语句抛出一个异常（可以是自定义需继承Exception，也可以是java自己给

出的异常类）

-throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。

八、java各版本特性

-java5
-很重要的一个版本，有泛型、枚举、自动装箱/拆箱、可变参数、注解、foreach循环、静态导入、新的线程模型等等更新。

-java6
-鸡肋的版本，有JDBC4.0更新、Complier API、WebSevice支持的加强等更新。

-java7
-有一些比较重要的更新，如异常处理增加了被抑制的异常、捕获多异常、try-with-resource自动释放资源等，还有应用了

G1垃圾回收器、switch可以使用String类型、泛型自动判断类型、fork/join框架把任务细分并使用多处理器处理、支持二

进制字面量等

-java8         
-很多的新特性，比如编译器、类库、开发工具和JVM（Java虚拟机）。         

-最重要的一点，Java8开始支持了Lambda表达式    

-java9
-Java 平台级模块系统、Linking、Shell : 交互式 Java REPL、改进的 Javadoc等
